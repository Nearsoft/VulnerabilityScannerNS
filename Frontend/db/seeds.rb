# This file should contain all the record creation needed to seed the database with its default values.
# The data can then be loaded with the rails db:seed command (or created alongside the database with db:setup).
#
# Examples:
#
#   movies = Movie.create([{ name: 'Star Wars' }, { name: 'Lord of the Rings' }])



Vulnerability.create(alias: "xss",
                     name: "XSS",
                     description: "Cross-site scripting (XSS) is a type of computer security vulnerability typically found in web applications. XSS enables attackers to inject client-side scripts into web pages viewed by other configuration. A cross-site scripting vulnerability may be used by attackers to bypass access controls such as the same-origin policy. Cross-site scripting carried out on websites accounted for roughly 84% of all security vulnerabilities documented by Symantec as of 2007.",
                     prevention: "<p>Preventing XSS requires separation of untrusted data from active browser content.</p><ul>
<li>Use safer frameworks that automatically escape for XSS by design, such as in Ruby 3.0 or React JS.</li>
<li>Escaping untrusted HTTP request data based on the context in the HTML output (body, attribute, JavaScript, CSS, or URL) will resolve Reflected and Stored XSS vulnerabilities. The OWASP XSS Prevention Cheat Sheet has details on the required data escaping techniques.</li>
<li>Applying context sensitive encoding when modifying the browser document on the client side acts against DOM XSS. When this cannot be avoided, similar context sensitive escaping techniques can be applied to browser APIs as described in the OWASP DOM based XSS Prevention Cheat Sheet.</li>
<li>Enabling a Content Security Policy (CSP) is a defense in depth mitigating control against XSS, assuming no other vulnerabilities exist that would allow placing malicious code via local file include such as path traversal overwrites, or vulnerable libraries in permitted sources, such as content delivery network or local libraries.</li></ul>")

Vulnerability.create(alias: "blindsqli",
                     name: "Blind SQL Injection",
                     description: "Blind SQL (Structured Query Language) injection is a type of SQL Injection attack that asks the database true or false questions and determines the answer based on the applications response. This attack is often used when the web application is configured to show generic error messages, but has not mitigated the code that is vulnerable to SQL injection. When an attacker exploits SQL injection, sometimes the web application displays error messages from the database complaining that the SQL Query's syntax is incorrect. Blind SQL injection is nearly identical to normal SQL Injection, the only difference being the way the data is retrieved from the database. When the database does not output data to the web page, an attacker is forced to steal data by asking the database a series of true or false questions. This makes exploiting the SQL Injection vulnerability more difficult, but not impossible.",
                     prevention: "Have your developers identify where data enters or exits the application and ensure that validation occurs for every part of the HTTP request before letting it anywhere near scripts, data access routines and SQL queries. This will prevent user-supplied data from being able to modify the syntax of SQL statements.")

Vulnerability.create(alias: "headersqli",
                     name: "HTTP SQL Injection",
                     description: "This indicates an attempt to exploit a SQL-injection vulnerability through HTTP headers.
The vulnerability is a result of the application's failure to check user supplied input before using it in an SQL query. As a result, a remote attacker can send a crafted query to execute SQL commands on a vulnerable server.",
                     prevention: "Use parameterized queries when dealing with SQL queries that contains user input. Parameterized queries allows the database to understand which parts of the SQL query should be considered as user input, therefore solving SQL injection.")

Vulnerability.create(alias: "headerxss",
                     name: "XSS in HTTP Headers",
                     description: "Cross-site scripting in an HTTP headers attack is an XSS attack which uses HTTP header fields as entry points for injecting the payload and depends on the improper return of user controlled HTTP header values in HTTP responses.",
                     prevention: "The best defense in this case, like in the case of other XSS attacks, is sanitization. Developers can make sure that user input does not make it into server generated HTML headers unless really necessary. This way, the prerequisites for this type of attack are eliminated. However, there are cases where user input needs to be encoded in the HTTP headers and, in these situations, developers can implement filters that sanitize this content and eliminates any scripting tags, thus removing the possibility of exploiting potential entry points that meet the prerequisites of this type of attack.")

Vulnerability.create(alias: "htmli",
                     name: "HTML Injection",
                     description: "HTML injection is a type of injection issue that occurs when a user is able to control an input point and is able to inject arbitrary HTML code into a vulnerable web page. This vulnerability can have many consequences, like disclosure of a user's session cookies that could be used to impersonate the victim, or, more generally, it can allow the attacker to modify the page content seen by the victims.",
                     prevention: "Do not rely on client-side JavaScript validation whenever possible; this is easily deceived using 'in-line' injection.
</br>
</br>Don't store sensible data into cookies, because they can be easily modified by an attacker. If you need to store data in cookies, store them with a hash signature generated with a server side key.
</br>
</br>Never use hidden boxes to hold items because they can be hard coded into the code. Otherwise, you should always validate the fields at server side using a secure algorithm, with data received from the client as input.
</br>
</br>If you are developing a web site that allows the user to upload content (forum, guestbook, 'contact me', etc.), you may split special HTML chars, so injected tags will be maintained in the website, but will not be executed; you can get this with the strip_tags() PHP function, htmlentities(), urlencode(), or htmlspecialchars(), for example.
</br>
</br>Use an SSL certificate for sensible operations; this doesn't avoid JavaScript injection, but avoids sensible data from being read by anyone else.")

Vulnerability.create(alias: "oscommand",
                     name: "OS Command Injection",
                     description: "Operating system command injection vulnerabilities arise when an application incorporates user-controllable data into a command that is processed by a shell command interpreter. If the user data is not strictly validated, an attacker can use shell metacharacters to modify the command that is executed, and inject arbitrary further commands that will be executed by the server.
<br>
<br>OS command injection vulnerabilities are usually very serious and may lead to compromise of the server hosting the application, or of the application's own data and functionality. It may also be possible to use the server as a platform for attacks against other systems. The exact potential for exploitation depends upon the security context in which the command is executed, and the privileges that this context has regarding sensitive resources on the server.",
                     prevention: "If possible, applications should avoid incorporating user-controllable data into operating system commands. In almost every situation, there are safer alternative methods of performing server-level tasks, which cannot be manipulated to perform additional commands than the one intended.
<br>
<br>If it is considered unavoidable to incorporate user-supplied data into operating system commands, the following two layers of defense should be used to prevent attacks:
<br>
<br>The user data should be strictly validated. Ideally, a whitelist of specific accepted values should be used. Otherwise, only short alphanumeric strings should be accepted. Input containing any other data, including any conceivable shell metacharacter or whitespace, should be rejected.
<br>
<br>The application should use command APIs that launch a specific process via its name and command-line parameters, rather than passing a command string to a shell interpreter that supports command chaining and redirection. For example, the Java API Runtime.exec and the ASP.NET API Process.Start do not support shell metacharacters. This defense can mitigate the impact of an attack even in the event that an attacker circumvents the input validation defenses.
")


Vulnerability.create(alias: "phpi",
                     name: "PHP Injection",
                     description: "Server-side code injection vulnerabilities arise when an application incorporates user-controllable data into a string that is dynamically evaluated by a code interpreter. If the user data is not strictly validated, an attacker can use crafted input to modify the code to be executed, and inject arbitrary code that will be executed by the server.
<br>
<br>Server-side code injection vulnerabilities are usually very serious and lead to complete compromise of the application's data and functionality, and often of the server that is hosting the application. It may also be possible to use the server as a platform for further attacks against other systems.",
                     prevention: "Whenever possible, applications should avoid incorporating user-controllable data into dynamically evaluated code. In almost every situation, there are safer alternative methods of implementing application functions, which cannot be manipulated to inject arbitrary code into the server's processing.
<br>
<br>If it is considered unavoidable to incorporate user-supplied data into dynamically evaluated code, then the data should be strictly validated. Ideally, a whitelist of specific accepted values should be used. Otherwise, only short alphanumeric strings should be accepted. Input containing any other data, including any conceivable code metacharacters, should be rejected.")


    Vulnerability.create(alias: "sqli",
                         name: "SQL Injection",
                         description: "SQL injection vulnerabilities arise when user-controllable data is incorporated into database SQL queries in an unsafe manner. An attacker can supply crafted input to break out of the data context in which their input appears and interfere with the structure of the surrounding query.
<br>
<br>A wide range of damaging attacks can often be delivered via SQL injection, including reading or modifying critical application data, interfering with application logic, escalating privileges within the database and taking control of the database server.",
                         prevention: "The most effective way to prevent SQL injection attacks is to use parameterized queries (also known as prepared statements) for all database access. This method uses two steps to incorporate potentially tainted data into SQL queries: first, the application specifies the structure of the query, leaving placeholders for each item of user input; second, the application specifies the contents of each placeholder. Because the structure of the query has already been defined in the first step, it is not possible for malformed data in the second step to interfere with the query structure.")


    Vulnerability.create(alias: "xxe",
                         name: "XML Injection",
                         description: "XML external entity (XXE) injection vulnerabilities arise when applications process user-supplied XML documents without disabling references to external resources. XML parsers typically support external references by default, even though they are rarely required by applications during normal usage.
<br>
<br>External entities can reference files on the parser's filesystem; exploiting this feature may allow retrieval of arbitrary files, or denial of service by causing the server to read from a file such as /dev/random.
<br>
<br>External entities can often also reference network resources via the HTTP protocol handler. The ability to send requests to other systems can allow the vulnerable server to be used as an attack proxy. By submitting suitable payloads, an attacker can cause the application server to attack other systems that it can interact with. This may include public third-party systems, internal systems within the same organization, or services available on the local loopback adapter of the application server itself. Depending on the network architecture, this may expose highly vulnerable internal services that are not otherwise accessible to external attackers.",
                         prevention: "Parsers that are used to process XML from untrusted sources should be configured to disable processing of all external resources. This is usually possible, and will prevent a number of related attacks. You should consult the documentation for your XML parsing library to determine how to achieve this.
<br>
<br>XML external entity injection makes use of the DOCTYPE tag to define the injected entity. It may also be possible to disable the DOCTYPE tag or use input validation to block input containing it.")


    Vulnerability.create(alias: "ldapi",
                         name: "LDAP Injecion",
                         description: "LDAP injection arises when user-controllable data is copied in an unsafe way into an LDAP query that is performed by the application. If an attacker can inject LDAP metacharacters into the query, then they can interfere with the query's logic. Depending on the function for which the query is used, the attacker may be able to retrieve sensitive data to which they are not authorized, or subvert the application's logic to perform some unauthorized action.
<br>
<br>Note that automated difference-based tests for LDAP injection flaws can often be unreliable and are prone to false positive results. Scanner results should be manually reviewed to confirm whether a vulnerability is actually present.",
                         prevention: "If possible, applications should avoid copying user-controllable data into LDAP queries. If this is unavoidable, then the data should be strictly validated to prevent LDAP injection attacks. In most situations, it will be appropriate to allow only short alphanumeric strings to be copied into queries, and any other input should be rejected. At a minimum, input containing any LDAP metacharacters should be rejected; characters that should be blocked include ( ) ; , * | & = and whitespace.")






# Analysis.create(url: 'http://www.xyzpub.com/en/ruby-on-rails/', is_scan_completed: 0, analysis_date: '2018-04-10 01:01:23.442000', user_id: 1)
# Analysis.create(url: 'https://www.raywenderlich.com', is_scan_completed: 1, analysis_date: '2018-06-11 01:01:23.442000', user_id: 1)
# Analysis.create(url: 'http://www.google.com', is_scan_completed: 0, analysis_date: '2018-01-19 01:01:23.442000', user_id: 1)
# Analysis.create(url: 'http://www.nearsoft.com/', is_scan_completed: 1, analysis_date: '2018-02-22 01:01:23.442000', user_id: 1)
# Analysis.create(url: 'http://www.youtube.com', is_scan_completed: 1, analysis_date: '2018-09-06 01:01:23.442000', user_id: 1)
# Analysis.create(url: 'http://www.training.nearsoft.com', is_scan_completed: 0, analysis_date: '2018-04-14 01:01:23.442000', user_id: 1)
# Analysis.create(url: 'https://www.dropbox.com', is_scan_completed: 1, analysis_date: '2018-06-10 01:01:23.442000', user_id: 1)
# Analysis.create(url: 'https://hootsuite.com', is_scan_completed: 1, analysis_date: '2018-06-10 01:01:23.442000', user_id: 1)
# Analysis.create(url: 'https://materializecss.com', is_scan_completed: 0, analysis_date: '2018-04-14 01:01:23.442000', user_id: 2)
# Analysis.create(url: 'https://laracasts.com', is_scan_completed: 0, analysis_date: '2018-04-10 01:01:23.442000', user_id: 2)
# Analysis.create(url: 'https://www.apple.com', is_scan_completed: 0, analysis_date: '2018-04-10 01:01:23.442000', user_id: 2)
# Analysis.create(url: 'http://www.facebook.com', is_scan_completed: 0, analysis_date: '2018-09-06 01:01:23.442000', user_id: 2)
# Analysis.create(url: 'https://bitfountain.teachable.com', is_scan_completed: 0, analysis_date: '2018-06-11 01:01:23.442000', user_id: 2)
#
#
# AnalysisTestsVulnerability.create(vulnerability_id: 1, analyses_id: 1)
# AnalysisTestsVulnerability.create(vulnerability_id: 2, analyses_id: 1)
# AnalysisTestsVulnerability.create(vulnerability_id: 1, analyses_id: 2)
# AnalysisTestsVulnerability.create(vulnerability_id: 2, analyses_id: 3)
# AnalysisTestsVulnerability.create(vulnerability_id: 1, analyses_id: 3)
# AnalysisTestsVulnerability.create(vulnerability_id: 1, analyses_id: 4)
# AnalysisTestsVulnerability.create(vulnerability_id: 2, analyses_id: 5)
# AnalysisTestsVulnerability.create(vulnerability_id: 1, analyses_id: 6)
# AnalysisTestsVulnerability.create(vulnerability_id: 2, analyses_id: 7)
#
#
# SecurityFlaw.create(url: "http://www.xyzpub.com/en/ruby-on-rails/", payload: "asndajsnda", vulnerability_id: 1,analyses_id: 1 )
# SecurityFlaw.create(url: "https://www.raywenderlich.com", payload: "asndajsnda", vulnerability_id: 2,analyses_id: 1 )
# SecurityFlaw.create(url: "http://www.google.com", payload: "asndajsnda", vulnerability_id: 1,analyses_id: 2 )
# SecurityFlaw.create(url: "http://www.nearsoft.com/", payload: "asndajsnda", vulnerability_id: 1,analyses_id: 3 )
# SecurityFlaw.create(url: "http://www.youtube.com", payload: "asndajsnda", vulnerability_id: 1,analyses_id: 4 )
# SecurityFlaw.create(url: "http://www.training.nearsoft.com", payload: "asndajsnda", vulnerability_id: 2,analyses_id: 5 )